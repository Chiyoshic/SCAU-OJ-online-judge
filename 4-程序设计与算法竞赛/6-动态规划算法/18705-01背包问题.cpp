#include <iostream> // 只需要iostream头文件用于输入输出
using namespace std;

int main() {
    int M, N;
    cin >> M >> N; // 读取背包容量M和物品数量N
    
    // 存储物品信息：W[i]表示第i件物品的重量，C[i]表示价值
    int W[31], C[31];
    for (int i = 1; i <= N; ++i) {
        cin >> W[i] >> C[i]; // 读取每件物品的重量和价值
    }
    
    /* 
    动态规划解法核心思想：
    1. 状态定义：dp[j]表示背包容量为j时的最大价值
    2. 状态转移方程：dp[j] = max(dp[j], dp[j-W[i]] + C[i])
    3. 空间优化：使用一维数组代替二维数组
    4. 关键技巧：必须逆序遍历背包容量，避免重复计算
    */
    int dp[201] = {0}; // 初始化dp数组为0
    
    // 动态规划核心过程
    for (int i = 1; i <= N; ++i) { // 遍历每件物品
        /*
        逆序遍历背包容量：
        1. 从最大容量M开始，直到当前物品的重量W[i]
        2. 这样可以确保每件物品只被考虑一次
        */
        for (int j = M; j >= W[i]; --j) {
            /* 
            状态转移方程：
            1. 不选当前物品：保持dp[j]不变
            2. 选当前物品：dp[j-W[i]] + C[i]
            取两者中的较大值更新dp[j]
            */
            dp[j] = max(dp[j], dp[j - W[i]] + C[i]);
        }
    }
    
    cout << dp[M] << endl; // 输出背包容量为M时的最大价值
    
    return 0;
}

/*
Description
有一个容积为M的背包和N件物品。第i件物品的体积W[i]，价值是C[i]。求解将哪些物品装入背包可使价值总和最大。每种物品只有一件，
可以选择放或者不放入背包。



输入格式
第一行：两个整数，M(背包容量，M<=200)和N(物品数量，N<=30)；
第2..N+1行：每行二个整数Wi，Ci，表示每个物品的重量和价值。


输出格式
一个数，表示最大总价值。


输入样例
10 4
2 1
3 3
4 5
7 9


输出样例
12
*/