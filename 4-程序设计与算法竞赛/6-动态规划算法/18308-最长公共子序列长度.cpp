#include <iostream>
using namespace std;

/*
 * 最长公共子序列(LCS)问题 - 动态规划解法
 * 算法思想：
 * 1. 定义状态：dp[i][j]表示字符串A前i个字符和字符串B前j个字符的LCS长度
 * 2. 状态转移方程：
 *    - 当A[i-1] == B[j-1]时，dp[i][j] = dp[i-1][j-1] + 1
 *    - 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])
 * 3. 初始化：dp[0][j] = dp[i][0] = 0 (空字符串与任何字符串的LCS长度为0)
 *
 * 记忆口诀：
 * 两串比较找相同，字符相等加一功
 * 不等取大左右看，动态规划解LCS
 */

int main() {
    string A, B;
    cin >> A >> B;
    
    int m = A.length();
    int n = B.length();
    
    int dp[m + 1][n + 1];
    
    /*
     * 动态规划求解过程：
     * 1. 外层循环遍历字符串A的每个字符
     * 2. 内层循环遍历字符串B的每个字符
     * 3. 根据状态转移方程填充dp数组
     *
     * 注意：
     * - dp数组的行列比字符串长度多1，用于处理空字符串情况
     * - 实际字符比较时索引要减1，因为dp[1][1]对应A[0]和B[0]
     */
    for (int i = 0; i <= m; ++i) {
        for (int j = 0; j <= n; ++j) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;  // 边界条件：空字符串的LCS长度为0
            } else if (A[i - 1] == B[j - 1]) {
                // 当前字符相等，LCS长度等于去掉这两个字符的子问题解加1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // 当前字符不等，取左边或上边较大的值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    cout << dp[m][n] << endl;
    
    return 0;
}
/*
Description
给定两个字符串，请输出这两个字符串的最大公共子序列



输入格式
两行，一行一个字符串（不包括空格，Tab键）,长度不超过1000


输出格式
输出最大公共子序列的长度


输入样例
abbca
aba


输出样例
3
*/