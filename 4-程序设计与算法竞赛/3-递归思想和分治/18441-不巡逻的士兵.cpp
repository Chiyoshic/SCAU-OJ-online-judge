#include <iostream>
#include <vector>
using namespace std;

/*
 * 不巡逻士兵问题 - 递归分治算法
 * 算法思想：
 * 1. 分治策略：将大问题分解为两个子问题（奇数位置和偶数位置）
 * 2. 记忆化搜索：使用数组存储已计算结果，避免重复计算
 * 3. 递归终止条件：当士兵数≤2时无解，等于3时有1种方案
 * 4. 最终结果计算：总士兵数减去3倍方案数
 */
vector<int> flag; // 记忆化数组，存储已计算结果

/*
 * 递归求解函数
 * 参数：number - 当前士兵数量
 * 返回值：当前士兵数量对应的方案数
 * 实现步骤：
 * 1. 检查终止条件
 * 2. 检查记忆化数组
 * 3. 分解子问题（奇数位置和偶数位置）
 * 4. 合并子问题结果
 * 5. 存储结果到记忆化数组
 */
int f(int number){
    // 终止条件：士兵数≤2时无解
    if(number <=2) return 0;
    // 终止条件：士兵数=3时有1种方案
    if(number==3) return 1;
    // 记忆化检查：如果已计算过，直接返回结果
    if(number<100001 && flag[number]!=0) return flag[number];

    // 分解子问题：分别计算奇数位置和偶数位置的方案数
    int odd = f(number/2);      // 去除偶数位置士兵后的子问题
    int even = f((number+1)/2); // 去除奇数位置士兵后的子问题
    
    // 合并结果：总方案数为两种情况的方案数之和
    int sum = odd + even;
    
    // 记忆化存储：将结果存入数组
    if(number<100001) flag[number] = sum;
    
    return sum;
}



/*
 * 主函数
 * 功能：处理输入输出，初始化记忆化数组
 * 优化点：
 * 1. 使用sync_with_stdio(false)加速IO
 * 2. 预处理记忆化数组
 * 3. 批量处理输入直到遇到0
 */
int main(){
    // 加速输入输出
    std::ios::sync_with_stdio(false);
    
    // 初始化记忆化数组
    flag.resize(100001, 0);
    flag[3] = 1; // 基础情况
    
    // 处理输入
    int curr;
    cin >> curr;
    while(curr){
        // 输出结果：总士兵数减去3倍方案数
        if(curr<100001 && flag[curr]!=0) cout << curr - flag[curr]*3 << endl;
        else cout << curr - f(curr)*3 << endl;
        
        // 读取下一个输入
        cin >> curr;
    }
    
    return 0;
}

/*
Description
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数之后，输出有多少个位置上的士兵是不可能被选中去巡逻的。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 21亿



输入格式
有多行（可能有上百行，请尽量优化代码），每行一个数字N，最后一行是0


输出格式
对每一行的数字N，不可能被选中去巡逻的位置数

直到没有数字


输入样例
10
6
0


输出样例
4
0
*/