#include <iostream>
using namespace std;

/*
 * 不被选中巡逻的士兵最小编号问题 - 递归分治算法
 * 算法思想：
 * 1. 分治策略：将问题分解为奇数位置和偶数位置的子问题
 * 2. 递归终止条件：当士兵编号满足特定条件时直接返回结果
 * 3. 合并策略：比较子问题结果，返回最优解
 * 记忆方法：
 * 1. 记住关键条件：n+q <= m && n+q+q > m 时返回n
 * 2. 递归过程类似于二分查找，每次将问题规模减半
 */
/*
 * 递归求解函数
 * 参数说明：
 *   n - 当前考虑的起始编号
 *   q - 当前步长（用于确定奇数/偶数位置）
 *   m - 士兵总数
 * 返回值：不可能被选中的最小编号（0表示不存在）
 * 算法步骤：
 * 1. 基础情况处理：当士兵数≤2时直接返回1
 * 2. 检查终止条件：
 *    - 当n+q+q <= m && n+q+q+q > m时返回0（该区间无解）
 *    - 当n+q <= m && n+q+q > m时返回n（该区间最优解）
 * 3. 递归分解：
 *    - 处理奇数位置子问题：f(n+q, q*2, m)
 *    - 处理偶数位置子问题：f(n, q*2, m)
 * 4. 合并结果：返回最优解（最小有效编号或最大可能解）
 */
int f(int n, int q, int m){
    // 基础情况：当士兵数≤2时直接返回1
    if(m==1 || m==2) return 1;
    
    // 终止条件1：当前区间无解
    if(n+q+q <= m && n+q+q+q > m) return 0;
    
    // 终止条件2：当前区间有解，返回最小编号n
    if(n+q <= m && n+q+q > m) return n;

    // 递归分解：分别处理奇数位置和偶数位置的子问题
    int odd = f(n+q, q*2, m);  // 奇数位置子问题
    int even = f(n, q*2, m);    // 偶数位置子问题
    
    // 合并结果：返回最优解
    if(odd != 0 && even != 0) return min(odd, even);  // 都有解时取最小
    else return max(odd, even);                       // 否则取有效解
}

/*
 * 主函数
 * 功能：处理输入输出
 * 优化点：
 * 1. 使用sync_with_stdio(false)加速IO
 * 2. 批量处理输入直到遇到0
 * 使用说明：
 * 1. 输入多行数字，每行一个士兵数量N
 * 2. 程序会输出对应N的最小编号
 * 3. 输入0时程序结束
 */
int main(){
    // 加速输入输出
    std::ios::sync_with_stdio(false);
    
    int curr;
    cin >> curr;
    
    // 处理多组输入
    while(curr){
        // 计算并输出结果
        cout << f(1, 1, curr) << endl;
        
        // 读取下一个输入
        cin >> curr;
    }
    
    return 0;
}

/*
Description
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数之后，输出不可能被选中去巡逻的最少编号位置（如果不存在不可能被选中的位置，则输出0）。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 100000



输入格式
有多行（不多于20行），每行一个数字N，最后一行是0


输出格式
对每一行的数字N，不可能被选中去巡逻的最小位置

直到没有数字


输入样例
9
6
0


输出样例
2
0
*/