#include <iostream>
using namespace std;

/*
 * 判断士兵是否会被选中巡逻 - 递归分治算法
 * 算法思想：
 * 1. 分治策略：将问题分解为奇数位置和偶数位置的子问题
 * 2. 递归终止条件：
 *    - 当位置p无效时直接返回false
 *    - 当士兵数n=3时返回true（会被选中）
 *    - 当士兵数n<3时返回false（不会被选中）
 * 3. 合并策略：使用逻辑或运算合并子问题结果
 * 记忆方法：
 * 1. 记住关键条件：n=3是终止条件
 * 2. 递归过程类似于二分查找，每次将问题规模减半
 */
bool canBeSelected(int n, int p) {
    // 边界条件：位置p无效
    if (p < 1 || p > n) return false;
    // 终止条件1：当士兵数=3时会被选中
    if (n == 3) return true;
    // 终止条件2：当士兵数<3时不会被选中
    if (n < 3) return false;
    
    bool res = false;
    
    // 处理奇数位置的情况
    if (p % 2 == 1) {
        int new_p = (p + 1) / 2;  // 计算新位置
        int m = (n + 1) / 2;      // 计算新士兵数
        res |= canBeSelected(m, new_p);  // 递归求解子问题
    }
    
    // 处理偶数位置的情况
    if (p % 2 == 0) {
        int new_p = p / 2;        // 计算新位置
        int m = n / 2;            // 计算新士兵数
        res |= canBeSelected(m, new_p);  // 递归求解子问题
    }
    
    return res;
}

/*
 * 主函数
 * 功能：处理输入输出
 * 优化点：
 * 1. 使用sync_with_stdio(false)加速IO
 * 2. 使用cin.tie(0)解除cin与cout的绑定
 * 3. 批量处理输入直到遇到0 0
 */
int main() {
    // 加速输入输出
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n, p;
    // 循环读取输入
    while (cin >> n >> p) {
        // 终止条件：输入0 0时结束
        if (n == 0 && p == 0) break;
        // 输出结果：Y表示会被选中，N表示不会被选中
        cout << (canBeSelected(n, p) ? 'Y' : 'N') << '\n';
    }
    
    return 0;
}
/*
Description
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数，以及位置编号，判断站在该位置编号的战士是否可能被抽中巡逻。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 100000



输入格式
有多行（不多于10000行），每行两个数字，第一个数字是士兵人数，第二个数字是位置编号，最后一行是两个0，表示结束


输出格式
对每一行输入，输出一行结果，能被抽中输出Y，不能抽中输出N

最后一行两个0不需要


输入样例
4 1
5 1
0 0


输出样例
N
Y
*/